# 🧩 Product Serving - Online Serving & Web Programming Logic

## **1️⃣ Online Serving**

### 💡 정의
- **Online Serving**은 사용자의 요청이 들어올 때마다 **실시간으로 모델이 예측 결과를 반환**하는 방식입니다.  
- 즉, 클라이언트가 요청을 보내면 서버가 즉시 데이터를 처리하여 응답을 돌려줍니다.  
- **실시간성(real-time)**이 요구되는 환경에서 사용되며, 대표적으로 추천 시스템, 주문 처리, 실시간 예측 등에 활용됩니다.

### 💬 예시
- **배달 플랫폼**: 고객이 주문할 때마다 실시간으로 예상 배달시간과 추천 메뉴를 계산.  
  → 실시간 교통 상황이나 품절 여부 등 시점별 input이 다르기 때문에 **Online Serving**이 필수적임.

---

## **2️⃣ Online Serving 구현 방식**

### 🧱 ① 직접 웹 서버 개발
- Flask, FastAPI 같은 프레임워크로 직접 서버를 구성.  
- 모델을 메모리에 로드하고, 요청마다 예측 수행 후 결과를 반환.  
- 구조와 동작 원리를 명확히 이해할 수 있지만 **서버 운영 및 확장 관리 부담**이 큼.

### ☁️ ② 클라우드 매니지드 서비스 활용
- AWS **SageMaker**, GCP **Vertex AI** 등에서 모델을 API 형태로 쉽게 배포.  
- **장점**: 인프라, 로깅, 버전 관리, 모니터링이 자동화되어 있어 개발 리소스 절약.  
- **단점**: 비용 증가 및 클라우드 종속성(vendor lock-in) 발생 가능.

### 🧩 ③ 오픈소스 Serving 프레임워크
- **TensorFlow Serving**, **TorchServe**, **MLFlow**, **BentoML** 등.  
- 각 라이브러리는 모델 서빙 패턴을 추상화하여 표준화된 구조 제공.  
- 단, 추상화된 프레임워크 의존이 높으면 내부 동작 이해가 부족해질 수 있음.  

---

## **3️⃣ Online Serving 설계 시 고려사항**

### ⚡ Latency(지연 시간) 최소화 전략
- **데이터 전처리 서버 분리** (Feature Store 등 활용).  
- **모델 경량화 및 최적화** (FP16, pruning, quantization).  
- **병렬 처리 및 캐싱**을 통해 요청 대기 시간 감소.  
- 병목 지점이 DB일 수도 있으므로, **전체 파이프라인 모니터링**이 중요.

### 🐳 Docker 기반 환경 관리
- Serving 과정에서는 Python, 패키지 버전 등 **Dependency 관리**가 중요함.  
- 동일한 환경 재현을 위해 **Docker Image / Compose** 사용을 권장.  

---

## **4️⃣ Server Architecture**

### 🏗️ ① 모놀리스 아키텍처 (Monolithic)
- 하나의 큰 서버 안에 모든 서비스 로직과 모델 코드가 포함된 구조.  
- **장점**: 단순하고 초기 개발이 빠름.  
- **단점**: 코드 결합도가 높아지고, 확장 및 수정이 어려워짐.  
- **적합한 상황**: 서비스 초기 단계, 소규모 팀, 빠른 MVP 개발.

---

### 🧱 ② 마이크로서비스 아키텍처 (Microservices)
- 기능별로 독립된 여러 서버(서비스)가 존재하며, API를 통해 통신.  
- **장점**: 서버 단위로 독립적 배포 및 확장 가능.  
  → 예: “요리 담당 서버”와 “비품 담당 서버”를 분리해 스케일링.  
- **단점**: 통신 구조 복잡, 서비스 간 연동 관리 필요.  
- **적합한 상황**: 서비스가 고도화되고 팀 규모가 큰 경우.

---

### ⚖️ ③ 아키텍처 선택 기준
| 구분 | Monolithic | Microservices |
|------|-------------|----------------|
| 규모 | 초기/소규모 서비스 | 중대형 서비스 |
| 인력 | 적은 개발 인력 | 다수의 팀, 독립 기능 |
| 배포 | 단일 배포 | 서비스별 개별 배포 |
| 복잡도 | 낮음 | 높음 |
| 확장성 | 제한적 | 유연함 |

---

## **5️⃣ API**

### 💡 정의
- **API (Application Programming Interface)**는  
  서로 다른 소프트웨어 간 **데이터와 기능을 주고받기 위한 인터페이스**입니다.  
- 즉, “사람이 아닌 프로그램끼리 소통하기 위한 규칙”.

---

## **6️⃣ Web API**

### 🌐 개념
- 웹 환경에서 **HTTP 프로토콜**을 통해 통신하는 API.  
- 클라이언트와 서버가 요청(request)과 응답(response) 형태로 상호작용.  
- 대표적 방식: **REST**, **GraphQL**, **RPC**.

---

## **7️⃣ REST API**

### 💡 핵심 개념
- **Representational State Transfer**:  
  자원(Resource)을 “표현(Representation)”하고 그 상태(State)를 “전송(Transfer)”하는 구조.  
- HTTP 메서드(GET, POST, PUT, PATCH, DELETE)를 통해 CRUD 동작 수행.

### 🧩 구성 요소
| 요소 | 설명 |
|------|------|
| **Resource** | 고유한 URI로 식별되는 자원 |
| **Method** | HTTP 동사 (GET, POST 등) |
| **Representation** | JSON, XML 등 데이터 표현 형식 |

---

### 🔍 URL Parameters
- **Query Parameter**: 데이터 필터링 또는 검색 (예: `/users?name=jin`)  
- **Path Parameter**: 특정 자원 식별 (예: `/users/jin`)  
→ 선택적 정보 vs 필수 정보에 따라 구분.

---

### 📦 Header & Payload
- **Header**: 요청의 메타데이터 (예: Content-Type: application/json)  
- **Payload**: 실제 전송할 데이터 본문.  
→ 클라이언트가 서버에 JSON 형태로 데이터를 전달할 때 사용.

---

### 📊 Status Code
| 코드 | 의미 | 설명 |
|------|------|------|
| 1xx | 정보 | 요청을 수신 중 |
| 2xx | 성공 | 요청 정상 처리 |
| 3xx | 리다이렉션 | 추가 조치 필요 |
| 4xx | 클라이언트 오류 | 잘못된 요청 |
| 5xx | 서버 오류 | 서버 내부 문제 |

---

## **8️⃣ 핵심 요약**

| 구분 | 내용 |
|------|------|
| **Online Serving** | 실시간 예측 방식, 응답속도 중요 |
| **Serving 구현 선택** | 직접 서버 / 클라우드 / 오픈소스 |
| **Server 아키텍처** | 모놀리스 vs 마이크로서비스 |
| **API** | 프로그램 간 통신 인터페이스 |
| **REST API** | HTTP 기반 자원 중심 통신 구조 |

---

### 💡 핵심 인사이트
> Serving의 목적은 "모델을 실제 서비스 환경에 연결"하는 것이며,  
> 구조(아키텍처)와 통신(API)를 이해하는 것이 코드 구현보다 선행되어야 한다.
